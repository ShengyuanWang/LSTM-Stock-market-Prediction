set_seed(123)
set.seed(123)
set.seed(123)
# Model Spec
lm_spec <-
linear_reg() %>%
set_engine(engine = 'lm') %>%
set_mode('regression')
# New Recipe (remove steps needed for LASSO, add splines)
spline_rec <- recipe(Grad.Rate ~ Private + Terminal + Expend + S.F.Ratio, data = college_clean) %>%
step_dummy(all_nominal_predictors()) %>%
step_ns(Terminal, deg_free = 3) %>%
step_ns(Expend, deg_free = 3)
# Workflow (Recipe + Model)
spline_wf <- workflow() %>%
add_recipe(spline_rec) %>%
add_model(lm_spec)
# CV to Evaluate
cv_output <- fit_resamples(
spline_wf, # workflow
resamples = data_cv8, # cv folds
metrics = metric_set(mae))
cv_output %>% collect_metrics()
# Fit with all data
ns_mod <- fit(
spline_wf, #workflow
data = college_clean)
ns_mod %>%
tidy()
spline_mod_output <- college_clean %>%
bind_cols(predict(ns_mod, new_data = college_clean)) %>%
mutate(resid = Grad.Rate - .pred)
# Residual plots
ggplot(spline_mod_output, aes(x = Terminal, y = resid)) +
geom_point() +
geom_smooth() +
geom_hline(yintercept = 0, color = "red") +
theme_classic()
ggplot(spline_mod_output, aes(x = Expend, y = resid)) +
geom_point() +
geom_smooth() +
geom_hline(yintercept = 0, color = "red") +
theme_classic()
ggplot(spline_mod_output, aes(x = S.F.Ratio, y = resid)) +
geom_point() +
geom_smooth() +
geom_hline(yintercept = 0, color = "red") +
theme_classic()
set.seed(123)
# Model Spec
lm_spec <-
linear_reg() %>%
set_engine(engine = 'lm') %>%
set_mode('regression')
# New Recipe (remove steps needed for LASSO, add splines)
spline_rec <- recipe(Grad.Rate ~ Private + Terminal + Expend + S.F.Ratio, data = college_clean) %>%
step_dummy(all_nominal_predictors()) %>%
step_ns(Terminal, deg_free = 3) %>%
step_ns(Expend, deg_free = 3)
# Workflow (Recipe + Model)
spline_wf <- workflow() %>%
add_recipe(spline_rec) %>%
add_model(lm_spec)
# CV to Evaluate
cv_output <- fit_resamples(
spline_wf, # workflow
resamples = data_cv8, # cv folds
metrics = metric_set(mae))
cv_output %>% collect_metrics()
# Fit with all data
ns_mod <- fit(
spline_wf, #workflow
data = college_clean)
ns_mod %>%
tidy()
spline_mod_output <- college_clean %>%
bind_cols(predict(ns_mod, new_data = college_clean)) %>%
mutate(resid = Grad.Rate - .pred)
# Residual plots
ggplot(spline_mod_output, aes(x = Terminal, y = resid)) +
geom_point() +
geom_smooth() +
geom_hline(yintercept = 0, color = "red") +
theme_classic()
ggplot(spline_mod_output, aes(x = Expend, y = resid)) +
geom_point() +
geom_smooth() +
geom_hline(yintercept = 0, color = "red") +
theme_classic()
ggplot(spline_mod_output, aes(x = S.F.Ratio, y = resid)) +
geom_point() +
geom_smooth() +
geom_hline(yintercept = 0, color = "red") +
theme_classic()
tune_output %>% collect_metrics() %>% filter(penalty == (best_penalty %>% pull(penalty)))
cv_output %>% collect_metrics()
spline_mod_output <- college_clean %>%
bind_cols(predict(ns_mod, new_data = college_clean)) %>%
mutate(resid = Grad.Rate - .pred)
# Residual plots
ggplot(spline_mod_output, aes(x = Terminal, y = resid)) +
geom_point() +
geom_smooth() +
geom_hline(yintercept = 0, color = "red") +
theme_classic()
ggplot(spline_mod_output, aes(x = Expend, y = resid)) +
geom_point() +
geom_smooth() +
geom_hline(yintercept = 0, color = "red") +
theme_classic()
ggplot(spline_mod_output, aes(x = S.F.Ratio, y = resid)) +
geom_point() +
geom_smooth() +
geom_hline(yintercept = 0, color = "red") +
theme_classic()
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(keras)
library(caret)
theme_set(theme_minimal())
set.seed(123)
# Load the data & clean the data
bitcoin_data <- read.csv("data/BCHAIN-MKPRU.csv") %>%
mutate(Date = as.Date(Date, "%m/%d/%y")) %>%
na.omit()
gold_data <- read.csv("data/LBMA-GOLD.csv") %>%
mutate(Date = as.Date(Date, "%m/%d/%y")) %>%
na.omit()
# Visualize data
bitcoin_data %>%
ggplot(aes(x = Date,
y = Value)) +
geom_line()
gold_data %>%
ggplot(aes(x = Date,
y = USD..PM.)) +
geom_line()
max_len <- 7
batch_size <- 32
total_epochs <- 15
bitcoin_price <- bitcoin_data$Value
table(bitcoin_price)
start_indexes <- seq(1, length(bitcoin_price) - (max_len + 1), by = 3)
bitcoin_matrix <- matrix(nrow = length(start_indexes), ncol = max_len + 1)
for (i in 1:length(start_indexes)) {
bitcoin_matrix[i,] <- bitcoin_price[start_indexes[i]:(start_indexes[i] + max_len)]
}
x <- bitcoin_matrix[,-ncol(bitcoin_matrix)]
y <- bitcoin_matrix[,ncol(bitcoin_matrix)]
training_index <- createDataPartition(y, p = 0.9,
list = FALSE,
times = 1)
x_train <- array(x[training_index,], dim = c(length(training_index), max_len, 1))
y_train <- y[training_index]
x_test <- array(x[-training_index,], dim = c(length(training_index), max_len, 1))
y_test <- y[-training_index]
model <- keras_model_sequential()
Y
install_tensorflow()
install.packages("tensorflow")
knitr::opts_chunk$set(echo = TRUE)
model <- keras_model_sequential()
model <- keras_model_sequential()
model <- keras_model_sequential()
install.packages("keras")
model <- keras_model_sequential()
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(keras)
library(caret)
theme_set(theme_minimal())
set.seed(123)
# Load the data & clean the data
bitcoin_data <- read.csv("data/BCHAIN-MKPRU.csv") %>%
mutate(Date = as.Date(Date, "%m/%d/%y")) %>%
na.omit()
gold_data <- read.csv("data/LBMA-GOLD.csv") %>%
mutate(Date = as.Date(Date, "%m/%d/%y")) %>%
na.omit()
# Visualize data
bitcoin_data %>%
ggplot(aes(x = Date,
y = Value)) +
geom_line()
gold_data %>%
ggplot(aes(x = Date,
y = USD..PM.)) +
geom_line()
max_len <- 7
batch_size <- 32
total_epochs <- 15
bitcoin_price <- bitcoin_data$Value
table(bitcoin_price)
start_indexes <- seq(1, length(bitcoin_price) - (max_len + 1), by = 3)
bitcoin_matrix <- matrix(nrow = length(start_indexes), ncol = max_len + 1)
for (i in 1:length(start_indexes)) {
bitcoin_matrix[i,] <- bitcoin_price[start_indexes[i]:(start_indexes[i] + max_len)]
}
x <- bitcoin_matrix[,-ncol(bitcoin_matrix)]
y <- bitcoin_matrix[,ncol(bitcoin_matrix)]
training_index <- createDataPartition(y, p = 0.9,
list = FALSE,
times = 1)
x_train <- array(x[training_index,], dim = c(length(training_index), max_len, 1))
y_train <- y[training_index]
x_test <- array(x[-training_index,], dim = c(length(training_index), max_len, 1))
y_test <- y[-training_index]
model <- keras_model_sequential()
install_tensorflow()
install tensorflow()
}
install tensorflow()
model <- keras_model_sequential()
install.packages("tensorflow")
knitr::opts_chunk$set(echo = TRUE)
library(tensorflow)
use_condaenv("r-tensorflow")
install_keras()
model <- keras_model_sequential()
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(keras)
library(caret)
library(tensorflow)
theme_set(theme_minimal())
set.seed(123)
# Load the data & clean the data
bitcoin_data <- read.csv("data/BCHAIN-MKPRU.csv") %>%
mutate(Date = as.Date(Date, "%m/%d/%y")) %>%
na.omit()
gold_data <- read.csv("data/LBMA-GOLD.csv") %>%
mutate(Date = as.Date(Date, "%m/%d/%y")) %>%
na.omit()
# Visualize data
bitcoin_data %>%
ggplot(aes(x = Date,
y = Value)) +
geom_line()
gold_data %>%
ggplot(aes(x = Date,
y = USD..PM.)) +
geom_line()
max_len <- 7
batch_size <- 32
total_epochs <- 15
bitcoin_price <- bitcoin_data$Value
table(bitcoin_price)
start_indexes <- seq(1, length(bitcoin_price) - (max_len + 1), by = 3)
bitcoin_matrix <- matrix(nrow = length(start_indexes), ncol = max_len + 1)
for (i in 1:length(start_indexes)) {
bitcoin_matrix[i,] <- bitcoin_price[start_indexes[i]:(start_indexes[i] + max_len)]
}
x <- bitcoin_matrix[,-ncol(bitcoin_matrix)]
y <- bitcoin_matrix[,ncol(bitcoin_matrix)]
training_index <- createDataPartition(y, p = 0.9,
list = FALSE,
times = 1)
x_train <- array(x[training_index,], dim = c(length(training_index), max_len, 1))
y_train <- y[training_index]
x_test <- array(x[-training_index,], dim = c(length(training_index), max_len, 1))
y_test <- y[-training_index]
model <- keras_model_sequential()
library(tidyverse)
library(caret)
library(tensorflow)
library(keras)
use_condaenv("tf")
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(keras)
library(caret)
theme_set(theme_minimal())
set.seed(123)
# Load the data & clean the data
bitcoin_data <- read.csv("data/BCHAIN-MKPRU.csv") %>%
mutate(Date = as.Date(Date, "%m/%d/%y")) %>%
na.omit()
gold_data <- read.csv("data/LBMA-GOLD.csv") %>%
mutate(Date = as.Date(Date, "%m/%d/%y")) %>%
na.omit()
# Visualize data
bitcoin_data %>%
ggplot(aes(x = Date,
y = Value)) +
geom_line()
gold_data %>%
ggplot(aes(x = Date,
y = USD..PM.)) +
geom_line()
max_len <- 7
batch_size <- 32
total_epochs <- 15
bitcoin_price <- bitcoin_data$Value
start_indexes <- seq(1, length(bitcoin_price) - (max_len + 1), by = 3)
bitcoin_matrix <- matrix(nrow = length(start_indexes), ncol = max_len + 1)
for (i in 1:length(start_indexes)) {
bitcoin_matrix[i,] <- bitcoin_price[start_indexes[i]:(start_indexes[i] + max_len)]
}
x <- bitcoin_matrix[,-ncol(bitcoin_matrix)]
y <- bitcoin_matrix[,ncol(bitcoin_matrix)]
model <- keras_model_sequential()
model <- keras_model_sequential()
model <- keras_model_sequential()
keras_model_sequential()
knitr::opts_chunk$set(echo = TRUE)
install_keras()
library(tidyverse)
library(keras)
library(caret)
install_keras()
theme_set(theme_minimal())
set.seed(123)
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(keras)
library(caret)
install_keras()
theme_set(theme_minimal())
set.seed(123)
# Load the data & clean the data
bitcoin_data <- read.csv("data/BCHAIN-MKPRU.csv") %>%
mutate(Date = as.Date(Date, "%m/%d/%y")) %>%
na.omit()
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(keras)
library(caret)
# install_keras()
theme_set(theme_minimal())
set.seed(123)
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(keras)
library(caret)
# install_keras()
theme_set(theme_minimal())
set.seed(123)
# Load the data & clean the data
bitcoin_data <- read.csv("data/BCHAIN-MKPRU.csv") %>%
mutate(Date = as.Date(Date, "%m/%d/%y")) %>%
na.omit()
gold_data <- read.csv("data/LBMA-GOLD.csv") %>%
mutate(Date = as.Date(Date, "%m/%d/%y")) %>%
na.omit()
# Visualize data
bitcoin_data %>%
ggplot(aes(x = Date,
y = Value)) +
geom_line()
gold_data %>%
ggplot(aes(x = Date,
y = USD..PM.)) +
geom_line()
max_len <- 7
batch_size <- 32
total_epochs <- 15
bitcoin_price <- bitcoin_data$Value
start_indexes <- seq(1, length(bitcoin_price) - (max_len + 1), by = 3)
bitcoin_matrix <- matrix(nrow = length(start_indexes), ncol = max_len + 1)
for (i in 1:length(start_indexes)) {
bitcoin_matrix[i,] <- bitcoin_price[start_indexes[i]:(start_indexes[i] + max_len)]
}
# make sure it's numeric
weather_matrix <- weather_matrix * 1
# make sure it's numeric
bitcoin_matrix <- bitcoin_matrix * 1
# remove na's if you have them
if(anyNA(bitcoin_matrix)){
bitcoin_matrix <- na.omit(bitcoin_matrix)
}
x <- bitcoin_matrix[,-ncol(bitcoin_matrix)]
y <- bitcoin_matrix[,ncol(bitcoin_matrix)]
training_index <- createDataPartition(y, p = 0.9,
list = FALSE,
times = 1)
x_train <- array(x[training_index,], dim = c(length(training_index), max_len, 1))
y_train <- y[training_index]
x_test <- array(x[-training_index,], dim = c(length(training_index), max_len, 1))
y_test <- y[-training_index]
model <- keras_model_sequential()
dim(x_train)
# Input layer
model %>%
layer_dense(input_shape = dim(x_train)[2:3], units = max_len)
# Number of N = 6
model %>%
layer_simple_rnn(units = 6)
# Output
model %>%
layer_dense(units = 1, activation = 'sigmoid')
# Glimpse the model
summary(model)
# Metrics
model %>% compile(loss = 'binary_crossentropy',
optimizer = 'RMSprop',
metrics = c('accuracy'))
# Training the model
trained_model <- model %>% fit(
x = x_train, # sequence we're using for prediction
y = y_train, # sequence we're predicting
batch_size = batch_size, # how many samples to pass to our model at a time
epochs = total_epochs, # how many times we'll look @ the whole dataset
validation_split = 0.1) # how much data to hold out for testing as we go along
trained_model
plot(trained_model)
# Input layer
model %>%
layer_dense(input_shape = dim(x_train)[2:3], units = max_len)
# Number of N = 6
model %>%
layer_simple_rnn(units = 6)
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(keras)
library(caret)
#install_keras()
theme_set(theme_minimal())
set.seed(123)
write.table(bitcoin_data,"bitcoin_new.csv",row.names=FALSE,col.names=TRUE,sep=",")
bitcoin_data <- read.csv("data/BCHAIN-MKPRU.csv") %>%
mutate(Date = as.Date(Date, "%m/%d/%y")) %>%
na.omit()
gold_data <- read.csv("data/LBMA-GOLD.csv") %>%
mutate(Date = as.Date(Date, "%m/%d/%y")) %>%
na.omit()
write.table(bitcoin_data,"bitcoin_new.csv",row.names=FALSE,col.names=TRUE,sep=",")
write.table(bitcoin_data,"gold_new.csv",row.names=FALSE,col.names=TRUE,sep=",")
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(keras)
library(caret)
#install_keras()
theme_set(theme_minimal())
set.seed(123)
bitcoin_data <- read.csv("data/BCHAIN-MKPRU.csv") %>%
mutate(Date = as.Date(Date, "%m/%d/%y")) %>%
na.omit()
gold_data <- read.csv("data/LBMA-GOLD.csv") %>%
mutate(Date = as.Date(Date, "%m/%d/%y")) %>%
na.omit()
gold_data <- read.csv("data/LBMA-GOLD.csv") %>%
na.omit()
# Load the data & clean the data
bitcoin_data <- read.csv("data/BCHAIN-MKPRU.csv") %>%
na.omit()
write.table(gold_data,"gold_data.csv",row.names=FALSE,col.names=TRUE,sep=",")
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(keras)
library(caret)
install_keras()
theme_set(theme_minimal())
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(keras)
library(caret)
#install_keras()
theme_set(theme_minimal())
set.seed(123)
# Load the data & clean the data
bitcoin_data <- read.csv("data/BCHAIN-MKPRU.csv") %>%
mutate(Date = as.Date(Date, "%m/%d/%y")) %>%
na.omit()
gold_data <- read.csv("data/LBMA-GOLD.csv") %>%
mutate(Date = as.Date(Date, "%m/%d/%y")) %>%
na.omit()
max_len <- 7
batch_size <- 32
total_epochs <- 15
bitcoin_price <- bitcoin_data$Value
start_indexes <- seq(1, length(bitcoin_price) - (max_len + 1), by = 3)
bitcoin_matrix <- matrix(nrow = length(start_indexes), ncol = max_len + 1)
for (i in 1:length(start_indexes)) {
bitcoin_matrix[i,] <- bitcoin_price[start_indexes[i]:(start_indexes[i] + max_len)]
}
# make sure it's numeric
bitcoin_matrix <- bitcoin_matrix * 1
# remove na's if you have them
if(anyNA(bitcoin_matrix)){
bitcoin_matrix <- na.omit(bitcoin_matrix)
}
x <- bitcoin_matrix[,-ncol(bitcoin_matrix)]
y <- bitcoin_matrix[,ncol(bitcoin_matrix)]
training_index <- createDataPartition(y, p = 0.9,
list = FALSE,
times = 1)
x_train <- array(x[training_index,], dim = c(length(training_index), max_len, 1))
y_train <- y[training_index]
x_test <- array(x[-training_index,], dim = c(length(training_index), max_len, 1))
y_test <- y[-training_index]
model <- keras_model_sequential()
# Input layer
model %>%
layer_dense(input_shape = dim(x_train)[2:3], units = max_len)
# Number of N = 6
model %>%
layer_simple_rnn(units = 6)
# Output
model %>%
layer_dense(units = 1, activation = 'relu')
# Glimpse the model
summary(model)
# Metrics
model %>% compile(loss = 'mean_squared_error',
optimizer = 'adam')
# Training the model
trained_model <- model %>% fit(
x = x_train, # sequence we're using for prediction
y = y_train, # sequence we're predicting
batch_size = batch_size, # how many samples to pass to our model at a time
epochs = total_epochs, # how many times we'll look @ the whole dataset
validation_split = 0.1) # how much data to hold out for testing as we go along
